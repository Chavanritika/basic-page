<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
         body{
          background:url('https://media.istockphoto.com/id/1686458179/photo/beautiful-abstract-grunge-decorative-navy-blue-dark-wall-texture-background-banner-with-space.webp?a=1&b=1&s=612x612&w=0&k=20&c=w_s0e_pAE2XOKPYiQot5E0tYVlNWL4rA6_eUQXXJR6g=');
    /* background: url('https://plus.unsplash.com/premium_photo-1672940671025-113a634f83d1?w=600&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8YmxhY2slMjBiYWNrZ3JvdW5kfGVufDB8fDB8fHww'); */
    background-repeat: no-repeat;
    background-size: cover;
    background-position: center; 
             /* gap: 30px;
            flex-wrap: wrap;    */
             /* width: 100%;  
             display: flex;
           justify-content: center;  
}     */
         }
.left{
    display:inline-block;
   position:absolute;
   left: 28px;
   top:25px;
}
.left h3{
    text-align: center;
    font-size: 1.5rem;
    color:#fdfcfd;
}

.mid{
    display:flex;
    justify-content: space-between;
    width: 28%;
    margin:0px auto;
    font-size: 30px;
    

   
}
       
.navbar{
    display:inline-block;
    padding-top: 5px;
}
        @media (max-width: 768px){
          .mid{
            flex-direction: column;
          }
        }
.navbar li{
    display: inline-block;
    font-size: 16px;
    
}

.navbar li a{
    color:rgb(255, 252, 252);
    text-decoration: none;  
    padding: 10px 5px;
}
.navbar li a:hover,.navbar li a:active{
  text-decoration: underline;
   color:#61dbfb; 
} 
 .Right{
    position:absolute;
    right: 80px;
    top:29px;
    display: inline-block;
 }

 .btn{
    display: inline;
    margin-top:1rem;
    border-radius:3rem;
    background:#fdfcfd;
    color:#040000;
    padding:0.4rem 1rem;
    cursor: pointer;
    font-size:1rem;
    border:0px;
    width: 100px; 
    
}

.btn:hover{
    background-color: #61dbfb;
    color:rgb(252, 251, 251);
}


 .content1{
            width: 400px;
            height: 700px;
            border-radius: 10px;
            border: 2px solid white;
            background-color: rgba(255, 255, 255, 0.182);
            overflow: auto;
            color: white;
            padding: 20px;
            scrollbar-width: none;
        }
        .content1 h1 a{
    text-decoration: none;
    color: #61dbfb;
        }
        .content2 h1 a{
    text-decoration: none;
    color: #61dbfb;
        }


        .content2{
            width: 1000px;
            height: 700px;
            border-radius: 10px;
            border: 2px solid white;
            background-color: rgba(255, 255, 255, 0.182);
            overflow: auto;
            color: white;
            scrollbar-width: none;
            scroll-behavior: smooth;
        padding: 20px;
        margin-top:0px;
        
        justify-content: center;
        flex: wrap;
        
        }
        .content2 img{
          height: 200px;
          width:600px;
        }
        .content2 h1{
          color:#61dbfb;
        }
        .content1 h1{
          color:#61dbfb;
        }
        .cont {
          display: flex;
          flex-direction: row;
          gap: 20px;
           /* flex-wrap: wrap;   */
        }
       @media (max-width: 768px){
          .cont{
            flex-direction: column;
          }
        }
        
    </style>
</head>

<body>
 
            <div class="left">
            <h3>STAR</h3>
             </div>

    <div class="mid">
         <ul class="navbar">
        <li><a href="#">Home</a></li>
        <li><a href="#">About Us</a></li>
         <li><a href="#">Products</a></li> 
        <li><a href="#">Reviews</a></li>
        <li><a href="#">Contact Us</a></li>
       </ul>


   
     <div class="Right">
        <button class="btn">Sign Up</button>
       <button class="btn">Log in </button>
    </div>
  </div>
  

    
  <div class="cont">
<div class="content1">
        <h1> <a href="#container">React Tutorial</a></h1>
      
        <h4>  React Home<br>
            <br>
            React Setup<br>
            <br>
            React Getting Started<br>
            <br>
            React ES6<br>
            <br>
            React Render HTML<br>
            <br>
            React JSX<br>
            <br>
            React Components<br>
            <br>
            React Class<br>
            <br>
            React Props<br>
            <br>
            React Events<br>
            <br>
            React Conditional<br>
            <br>
            React Lists<br>
            <br>
            React Forms<br>
            <br>
            React Router<br>
            <br>
            React Memo<br>
            <br>
            React CSS Styling</h4>
            
            <h1><a href="#container2">React Hooks</a></h1>
            
            <h4> What is a Hook?<br>
                <br>
                React useState Hook<br>
                <br>
                React useEffect Hook<br>
                <br>
                React useContext<br>
                <br>
                React useRef<br>
                <br>
                React useReducer<br>
                <br>
                React useCallback<br>
                <br>
                React useMemo</h4>

    </div>
    <p id="container">
    <div class="content2">
        <h1>React Tutorial</h1>
        <h2>React Home</h2>
<h3>What is ReactJS?</h3>
ReactJS is a JavaScript library used to build User Interfaces(UI). It significantly decreases the code with it's components, states i.e. hooks, etc. <br>

<h3>Creating react app</h3>
Open your terminal in the directory you would like to create your application. Run this command to create a React application named my-react-app:<br>

<h4>npx create-react-app my-react-app</h4>

OR, you can directly make your application without specifying a name, like this:

<h4>npx create-react-app .</h4>
In this case, all files will be kept in the current directory. 

Note: When choosing folder name, make sure there are no spaces or capital letters because of npm naming restrictions. 

Once base application is created, if folder specified you just have to enter the folder. You can use this command to enter:

<h4>cd directory-name</h4>

Then just start up the application with this command:

<h4>npm start</h4>
and you are good to go! 

<h3>Hello World</h3>
<h4>const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<h4>Hello, world!</h4>);</h4>
  

   <h1>React Setup</h1>
   <h4>Node.js</h4>
   You can download it from: https://nodejs.org/en/
   
   <h5>Creating our first react app</h5>

   <h4>npx create-react-app my-react-app</h4>
   
  <h4> npx create-react-app </h4>
  
  <h4> cd directory-name</h4>
   
  <h4> npm start</h4>
  <h2>React ES6</h2>
<h3>What is ES6?</h3>
ES6 stands for ECMAScript 6. ECMAScript is a JavaScript standard intended to ensure a common language across different browsers. ES6 is the 6th version of ECMAScript. 

<h3>Why ES6? / Features of ES6 / Upgrades in ES6</h3>
React uses ES6 and all of these new features will make your coding experience in react much much better. You will be able to do things with much more ease and in very less lines! Features like: 

<h4>Arrow Functions:</h4> 
const hello = () => {
  return "Hello World!";
}
or

const hello = () => "Hello World!";
<h4>.map():</h4> .map can be used for alot of things, one of it's use case is, we can make any number of cards through loop and just put it in jsx, like this:
const data = ['title1', 'title2', 'title3'];
let cards = data.map((item) => <card>{item}</card>)
<h3>Destructuring: </h3>
<h4>Old Way:</h4> 

const languages = ['JS', 'Python', 'Java'];
const js = languages[0]
const python = languages[1]
const java = languages[2]
<h4>New Way:</h4> 

const languages = ['JS', 'Python', 'Java'];
const [ js, python, java ] = languages
<h4>Ternary Operator:</h4> With this, you can write if/else conditions in one line. It's syntax is fairly simple like this:
condition ? <expression if true> : <expression if false>
Example:

let loading = false;
const data = loading ? <div>Loading...</div> : <div>Data</div>
<h4>Spread Operator:</h4>
const languages = ['JS', 'Python', 'Java'];
const morelanguages = ['C', 'C++', 'C#']

const allLanguages = [...languages, ...morelanguages]
<h4>Output:</h4>

["JS","Python","Java","C","C++","C#"]
<h1>React Render HTML</h1>
React renders HTML to the web page by using a function called ReactDOM.render().

<h3>ReactDOM.render()</h3>
This function takes two arguments, HTML content which you want to show on page and HTML element where you want to put the HTML content(first argument). 

But where will it find that element? It will find it inside "index.html" located in "public" folder. There you will notice a div with id "root". That is where all this will be rendered! 

<h4>ReactDOM.render(<p>Hello</p>, document.getElementById('root'));</h4>
<img src="https://cwh-full-next-space.fra1.digitaloceanspaces.com/tutorial/react-render-html/id-root.png" alt="">

<h1>React JSX</h1>
<h2>What is JSX?</h2>
JSX stands for JavaScript XML. It is similar in appearance to HTML, hence provides a way to easily write HTML in react. 

<h3>Coding in JSX</h3>
Earlier we had to make an HTML element or append it into existing ones with methods like createElement() / appendChild() 

const elem = React.createElement('h1', {}, 'Hello World!');
Now we can just do it directly, like this: 

const elem = <h5>Hello World!</h5>
<h3>Expressions in JSX</h3>
You can write the expression in {}

You can write simple mathematical operations to variable to states to complicated operations with ternary operators and it will return the result, like:

<h3>Mathematical Operations:</h3>

const elem = <h5>React was released in {2010+3}</h5>
<h3>Variables/States:</h3>

const name = "CWH"
const elem = <h5>My name is {name}</h5>
<h3>Ternary Operators:</h3>

const elem = <h5>Hello {name ? name : 'World'}</h5>
<h1>React Components</h1>
There are two types of components:

Class Based Components
Function Based Components
<h3>Class Based Components</h3>
Before making class based component we need to inherit functions from React.Component and this can be done with extends, like this:

<h4>class Cat extends React.Component {
    render() {
      return <h5>Meow</h5>;
    }
  }</h4>


<h3>Function Based Components</h3>
In function it's simpler, we just need to return the HTML, like this:

<h4>function Cat() {
    return <h5>Meow</h5>;
  }</h4>

<h3>Rendering a Component</h3>
We made a component, now we want to render/use it. Syntax for using a component is: 

<h4><ComponentName /></h4>
<h3>Components in Files</h3>
To have less mess inside main file(with all the components in the same file) and to resuse components on different pages, we have to make them separately. So that we can just import them in any file and use them! 

For that we will just make a new file called Cat.js, make class or function based component there and export default that class/function! Like this:

<h4>function Cat() {
    return <h5>Meow</h5>;
  }export default Cat;</h4>

 <h1> React Class</h1>
<h2>Class Based Components</h2>
Before making class based component we need to inherit functions from React.Component and this can be done with extends, like this:

<h4>class Cat extends React.Component {
    render() {
      return <h5>Meow</h5>;
    }
  }
  </h4>
<h2> Component Constructor</h2>
Constructor gets called when the component is initiated. This is where you initiate the component's properties. In React we have states which update on page without reload. Constructor properties are kept in state. 

We also need to add super() statement, which executes the parent component's constructor and component gets access to all the functions of the parent component, like this:

<h4>class Cat extends React.Component {
    constructor() {
      super();
      this.state = { color: "orange" };
    }
    render() {
      return <h5>Meow's color is {this.state.color}</h5>;
    }
  }</h4>
  <h1>React Props</h1>
  Props are arguments passed to React components via HTML attributes. Example: 
  
  <h2>Component:</h2>
  
  <h4>function Cat(props) {
    return <h5>Meow's color is {props.color}</h5>;
  }</h4>

  <h1>React Events</h1>
If you have coded even a little bit in javascript, you know the importance of events. 

<h2>Events</h2>
Every HTML attribute in React is written in camelCase syntax. Event is also an attribute. Hence, written in camelCase.

As we learnt variables, states, javascript operations are written in curly braces {}, same is true with React event handlers too! Like this: onClick={show} 

<h4><button onClick={show}>Show</button></h4>
<h2>Arguments in events</h2>
We can't pass arguments just like that, it will give syntax error. First, we need to put the whole function in arrow function, like this:
<!-- <h4><button onClick={ ()=>show('true')}>Show</button></h4> -->
<h2>React Event Object</h2>
Event handler can be provided to the function like this:

<!-- <h4><button onClick={ (event)=>show('true', event) }>Show</button></h4> -->

<h1>React Conditional</h1>
One of the best thing in React is in React we can conditionally render elements/components! 

<h2>&& Operator</h2>
This is one of the way to conditionally render:

<h4>function App() {

    const loading = true;
  
    return (
      <div className="App">
        {loading && <LoadingGif />}
        {!loading && <Content />}
      </div>
    );
  }</h4>
Here we are saying if loading is true then show <LoadingGif /> and in second line, we said !loading so that returns false in this case so <Content /> will not load and first statement is true so <LoadingGif /> will load! 

<h2>Ternary Operator</h2>
What we were doing in previous example was basically just if statement. We don't have else so we were using if as else too. Let's learn how to do both(if/else)!

Same thing can be done like this:

<h4>function App() {

    const loading = true;
  
    return (
      <div className="App">
        {loading ? <LoadingGif /> : <Content />}
      </div>
    );
  }</h4>
<h1>  React Forms</h1>
  React Forms are mostly like normal HTML forms, except we use state in this to handle inputs. 
  
  <h3>Handling Forms</h3>
  In React all the data is handled by component and stored in component state. We can change state with event handlers in the onChange attribute.
  <h3>Submitting Form</h3>
We can submit form with onSubmit attribute for the <form>
    <h3>Multiple Inputs</h3>
We don't have to make multiple states for multiple inputs, we can save all values in one.

<h1>React Router</h1>
React router is used for page routing as React App doesn't include it as default. 
<h3> Add React Router</h3>
To install React router, run this in your terminal:

<h4>npm i -D react-router-dom</h4>
<h3>Creating Multiple Routes</h3>
To do this first we need to create multiple files and to keep code clean, we will make a folder and make all the pages there, hence we will create a folder named pages in src. 

<h3>Folder Structure:</h3>
<h4>src/pages/:</h4>

Home.js,
Blogs.js,
Contact.js,
Nopage.js.

<h1>React Memo</h1>
By default React re-renders components again and again. Using memo will stop that if props have not changed. 

<h2>Problem</h2>
When we make components like Navbar, Footer, they re-render even if there is no change in them. To test this you can make a Navbar component and import it. Put a console.log, if it is logging, it means navbar is re-rendering. 

<h2>Solution</h2>
So what's the solution for this? Because this re-rendering is just wastage of resources. 

memo is a simple solution for this! What memo does is, it just monitors if props have changed, if they have it re-renders, if they haven't it doesn't render again. 

props is an object and javascript is very fast in comparing objects as it doesn't compare the whole object, it just checks the address! 

<h2>Importing memo</h2>
To use it, first we need to import memo. It can be imported like this:

<h4>import { memo } from "react";</h4>
<h2>Using memo</h2>
Everything remains the same, just when you are exporting the Navbar, you have to wrap it in memo, like this:
<h4>
    export default memo(Navbar);</h4>

    <h1>React CSS Styling</h1>
<h3>There are three ways to style in React:</h3>

Inline Styling
CSS Stylesheets
CSS Modules
</p>
<p id="container2">
<h1>React Hooks</h1>
<h2>What is a Hook?</h2>
Hooks were added to React in version 16.8. Hooks let you use state and other React features without writing a class.

Although states have largely replaced classes in React, there is no plan of removing classes from React. 
<h3>
    Things you need to keep in mind while using hooks:</h3>

You must import hook first
You must import it from react
Hooks can only be called in React Function Components, meaning:
<h4>/
    const Blogs = () => {
        
        return <h5>Blogs</h5>;
    };
    export default Blogs;</h4>


Hooks cannot be conditional
Hooks cannot work in React Class Components
Hooks can only be called at the top level of a component, meaning it can't be called from inside a block, i.e. {}. So, can't be called inside if, loops or any block, example:
<h4>const Blogs = () => {
   
    if (true){
       
    }
    return <h5>Blogs</h5>;
};

export default Blogs;</h4>


<h1>React useState Hook</h1>
useState is a Hook that lets you add React state to function components. 

<h2>Importing useState</h2>
To use useState, first we need to import useState and initialize it, you can import it from react like this:

<h4>import { useState } from "react";</h4>
<h2>Initializing useState</h2>
You can initialize state like this:

<h4>import { useState } from "react";

  const App = () => {
      const [name, setName] = useState('')
  };</h4>
useState takes initial state as argument and gives a state and a function(setName in this case) to update that state as we can't directly change/update a state. Also, these state names are just like variables, hence you can name them anything you like. 
<h2>
  Reading a state</h2>
As mentioned earlier, it returns a state and a function to change/update that state. Hence, everything is stored in name. We can read states just like variables:

<h4>import { useState } from "react";

  const App = () => {
      const [name, setName] = useState('')
  
      return <h5>My name is {name}</h5>
  };</h4>
<h1>Updating a state</h1>
To update state we use the function it returns to update state, in this case: setName. State can be updated like this:

<h4>import { useState } from "react";

  const App = () => {
      const [name, setName] = useState('')
      setName('Lovish')
  
      return <h5>My name is {name}</h5>
  };</h4>
<h2>What can state hold?</h2>
Like normal variables, state can hold any datatype like strings, numbers, booleans, arrays, objects, objects in arrays, arrays in objects. 





<h1> React useEffect Hook</h1>
The useEffect Hook allows you to perform side effects in your components.

useEffect accepts two arguments. The second one is optional. 

Runs on every render
Runs on first render
Runs when data changes


<h1>React useContext</h1>
useState is a Hook that lets you add React state to function components. useContext helps to manage states globally, i.e. between components. 

<!-- Problem
Suppose there is a button in <Navbar /> Component which affects something in <Home /> Component. Problems:

In this case, state can't be held in <Navbar /> or <Home />, it will be in App.js

To access it, we have to pass it like a prop to the components, and if the component is within 3-4 components, we have to pass it to everyone as shown in image below: 



 -->

    <img src="https://cwh-full-next-space.fra1.digitaloceanspaces.com/tutorial/react-usecontext/react-component-hierarchy.png" alt="" srcset="">
   <h3> Solution - Create Context</h3>
It's a hook so first we need to import it from react and initialize it! To do this, write:

<h4>import { createContext } from "react";

  const StateContext = createContext()</h4>
<h2>Context Provider</h2>
Now we need to wrap the component tree that need the state Context in a Provider. It's like the Provider will provide the state to every component in that tree which is wrapped in Provider. 

<h4>function App() {
  const [state, setState] = useState('true');

  return (
    <StateContext.Provider value={state}>
      <h5>{`Hi! My state is ${state}!`}</h5>
      <Home state={state} />
    </StateContext.Provider>
  );
}</h4>
<h2>useContext hook</h2>
First we need to import it:
<h4>import { useState, createContext, useContext } from "react";</h4>
To access useContext, you can do something like this:

<h4>function Home() {
  const state = useContext(StateContext);

  return (
    <>
      <h3>{`Hii! My state is ${state}! `}</h3>
    </>
  );
}</h4>
 

<h1>React useRef</h1>
useRef keeps the value stored between renders. 

In this, value changed doesn't cause a re-render. 

It can also be used to access a DOM element directly. 

Doesn't cause re-render
Accessing DOM elements with ref


<h2>React useReducer</h2>
useReducer is similar to useState hook. 

It lets you write your custom state logic. 

It lets you pass dispatch down instead of callbacks resulting in optimized performance for components that trigger deep updates. 

<h2>When to use useReducer?</h2>
useReducer is usually preferable to useState when you have complex state logic, changing more than 2-3 states in a function. 

<h2>Syntax</h2>
<h4>const [state, dispatch] = useReducer(reducer, initialState);</h4>



<h1>React useCallback</h1>
React useCallback Hook returns a memoized callback function.

It is done so that it does not need to be recalculated resulting in improved performance. 

If we don't use useCallback function would run on every render. This helps us to memoize resource intensive functions so that they will not automatically run on every render. 

With useCallback Hook, memoized function only runs when any of its dependencies update. 

<h2>When to use useCallback?</h2>
You may think we can use memo and stop a component from re-rendering but if there is a case where you are passing a function as prop to a component, then it will re-render irrespective of memo. It is because of something called "referential equality". In this every time a component re-renders, its function gets recreated. Hence, memo is working but because function is getting recreated, component will re-render. To avoid this, we can use useCallback! 

Like this:
<h4>
  const handleState = useCallback(() => {
    setState({...state, type: 'CONFIRMED'});
  }, [state])</h4>


<h1>React useMemo</h1>
React useMemo Hook returns a memoized value. 

It is similar to useCallback Hook. The main difference is useMemo returns a memoized value and useCallback returns a memoized function. 

The useMemo Hook only runs when any of its dependencies update. 

useMemo can improve performance big time. 

<h2>When to use it?</h2> 
Like if you have an expensive function like this:

<h4>const expensiveFunction = (num) => {
  console.log("Calculating...");
  for (let i = 0; i < 1000000000; i++) {
    num += 1;
  }
  return num;
};</h4>
This function will run on every render resulting in slowing down of everything. To prevent this, we can memoize it's result and return it without calculating and only recalculate it when num changes. 

For this we will make a state number because we have to give changing factor as dependency. Hence, code would be:

<h4>import { useMemo, useState } from "react";

  const App = () => {
    const [number, setNumber] = useState(0);
    const calculation = useMemo(() => expensiveFunction(number), [number]);
  
    return (
      <div>
        {calculation}
      </div>
    );
  };</h4>

<h4>const expensiveFunction = (num) => {
  console.log("Calculating...");
  for (let i = 0; i < 1000000000; i++) {
    num = num + i;
  }
  return num;
};

export default App;
</h4>
</p>
    

        
</div>
  </div>
  
</body>

</html>
